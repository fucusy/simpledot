#!/usr/bin/env python
# -*- coding: utf8 -*-
from __future__ import print_function
import argparse
import errno
import os
import re
import sys


IGNORE_LIST = ['.swp']
SOURCE = os.path.expanduser('~/.simpledot')
RE_DOTFILE = re.compile('dotfile\s+@\s+(.*)')

COLOR_PREFIX = '\033['
COLOR_RED = '31m'
COLOR_GREEN = '32m'
COLOR_RESET = '0m'


def colorize(s, color=None):
    if not color:
        return s

    constname = 'COLOR_{}'.format(color.upper())
    try:
        color = globals()[constname]
    except KeyError:
        print("unknown color '{}'".format(color), file=sys.stderr)
        return s

    return u''.join([COLOR_PREFIX, color, s, COLOR_PREFIX, COLOR_RESET])


def checkmark(checked):
    if checked:
        return colorize(u'✓', color='green')
    else:
        return colorize(u'✗', color='red')


def cmd_source(args):
    path = os.path.expanduser(args.path)
    if not os.path.exists(path):
        sys.exit("error: '{}' not found".format(path))

    if os.path.exists(SOURCE):
        sys.exit("error: '{}' already exists, delete it if you'd like to add"
                 " a different source".format(SOURCE))

    os.symlink(args.path, SOURCE)


def yield_annotations():
    if not os.path.exists(SOURCE):
        sys.exit("error: no sources, first use 'source' to add a directory")
    for root, dirnames, filenames in os.walk(SOURCE):
        for filename in filenames:
            ignore = False
            for suffix in IGNORE_LIST:
                if filename.endswith(suffix):
                    ignore = True
                    break
            if ignore:
                continue
            src = os.path.join(root, filename)
            with open(src) as f:
                match = RE_DOTFILE.search(f.read())
                if match:
                    dst =  match.group(1).strip()
                    dst = os.path.expanduser(dst)
                    yield src, dst


def cmd_list(args):
    print("Source: {}\n".format(SOURCE))
    for src, dst in yield_annotations():
        relsrc = os.path.relpath(src, SOURCE)
        exists = os.path.exists(dst)
        print(u"{} {:20} -> {}".format(checkmark(exists), relsrc, dst))


def cmd_up(args):
    for src, dst in yield_annotations():
        if not os.path.exists(src):
            print("warning: source file '{}' does not exist".format(src),
                  file=sys.stderr)
            continue
        if os.path.islink(src):
            print("warning: source file '{}' is a symbolic link".format(src),
                  file=sys.stderr)
            continue
        if os.path.exists(dst):
            print("warning: '{}' already exists".format(dst),
                  file=sys.stderr)
            continue

        dst_dirname = os.path.dirname(dst)
        try:
            os.makedirs(dst_dirname)
        except OSError as e:
            if e.errno != errno.EEXIST:
                raise
        os.symlink(src, dst)


def cmd_down(args):
    for src, dst in yield_annotations():
        if not os.path.exists(dst):
            print("warning: '{}' does not exist".format(dst),
                  file=sys.stderr)
            continue
        if not os.path.islink(dst):
            print("warning: '{}' is not a symbolic link".format(dst),
                  file=sys.stderr)
            continue
        os.unlink(dst)


def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    source_parser = subparsers.add_parser('list')
    source_parser.set_defaults(func=cmd_list)

    source_parser = subparsers.add_parser('source')
    source_parser.add_argument('path')
    source_parser.set_defaults(func=cmd_source)

    source_parser = subparsers.add_parser('up')
    source_parser.set_defaults(func=cmd_up)

    source_parser = subparsers.add_parser('down')
    source_parser.set_defaults(func=cmd_down)

    args = parser.parse_args()
    return args.func(args)


if __name__ == '__main__':
    main()
